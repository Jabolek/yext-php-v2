<?php
/**
 * CreateReportRequestBody
 *
 * PHP version 5
 *
 * @category Class
 * @package  Yext\Client
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache License v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Yext API
 *
 * 
 *
 * OpenAPI spec version: 2.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Yext\Client\Model;

use \ArrayAccess;

/**
 * CreateReportRequestBody Class Doc Comment
 *
 * @category    Class */
/**
 * @package     Yext\Client
 * @author      http://github.com/swagger-api/swagger-codegen
 * @license     http://www.apache.org/licenses/LICENSE-2.0 Apache License v2
 * @link        https://github.com/swagger-api/swagger-codegen
 */
class CreateReportRequestBody implements ArrayAccess
{
    /**
      * The original name of the model.
      * @var string
      */
    protected static $swaggerModelName = 'CreateReportRequestBody';

    /**
      * Array of property to type mappings. Used for (de)serialization
      * @var string[]
      */
    protected static $swaggerTypes = [
        'metrics' => 'string[]',
        'dimension' => 'string[]',
        'filters' => '\Yext\Client\Model\AnalyticsFilter'
    ];

    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of attributes where the key is the local name, and the value is the original name
     * @var string[]
     */
    protected static $attributeMap = [
        'metrics' => 'metrics',
        'dimension' => 'dimension',
        'filters' => 'filters'
    ];


    /**
     * Array of attributes to setter functions (for deserialization of responses)
     * @var string[]
     */
    protected static $setters = [
        'metrics' => 'setMetrics',
        'dimension' => 'setDimension',
        'filters' => 'setFilters'
    ];


    /**
     * Array of attributes to getter functions (for serialization of requests)
     * @var string[]
     */
    protected static $getters = [
        'metrics' => 'getMetrics',
        'dimension' => 'getDimension',
        'filters' => 'getFilters'
    ];

    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    public static function setters()
    {
        return self::$setters;
    }

    public static function getters()
    {
        return self::$getters;
    }

    

    

    /**
     * Associative array for storing property values
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     * @param mixed[] $data Associated array of property values initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['metrics'] = isset($data['metrics']) ? $data['metrics'] : null;
        $this->container['dimension'] = isset($data['dimension']) ? $data['dimension'] : null;
        $this->container['filters'] = isset($data['filters']) ? $data['filters'] : null;
    }

    /**
     * show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalid_properties = [];
        if ($this->container['metrics'] === null) {
            $invalid_properties[] = "'metrics' can't be null";
        }
        return $invalid_properties;
    }

    /**
     * validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properteis are valid
     */
    public function valid()
    {
        if ($this->container['metrics'] === null) {
            return false;
        }
        return true;
    }


    /**
     * Gets metrics
     * @return string[]
     */
    public function getMetrics()
    {
        return $this->container['metrics'];
    }

    /**
     * Sets metrics
     * @param string[] $metrics The kinds of data the report should include. Specify up to 10 values.  * **`PROFILE_VIEWS`**: the number of times your listings were viewed. Does not include listings on Yelp, Facebook, Bing, or Google. * **`SEARCHES`**: the number of times your listings were included in search results. Does not include search results on Yelp, Facebook, Bing, or Google. * **`POWERLISTINGS_LIVE`**: the total number of your listings that were live * **`FEATURED_MESSAGE_CLICKS`**: the number of times consumers clicked on your Featured Messsage. Does not include Featured Messages on Yelp, Facebook, Bing, or Google. * **`YELP_PAGE_VIEWS`**: number of times your listings on Yelp (\"pages\") were viewed * **`BING_SEARCHES`**: the number of times your listings were included in Bing search results. Because Bing sends data for full weeks rather than individual days, **`dimensions`** cannot contain `DAYS`, `MONTHS`, or `MONTHS_RETAIL` if `BING_SEARCHES` is in **`metrics`**. Also, reports with `BING_SEARCHES` have different reporting maximum dates than reports with other metrics. * **`FACEBOOK_LIKES`**: the total number of consumers who have \"liked\" your Page * **`FACEBOOK_TALKING_ABOUT`**: the number of unique consumers who had an interaction with your Page. For an interaction to be included in this total, it must result in a story being posted to the newsfeeds of those consumers' friends. Examples of these interactions include, but are not limited to, sharing a post on your Page, liking your Page, or tagging your location in a photo. * **`FACEBOOK_WERE_HERE`**: the total number of consumers who have checked into your business on Facebook, along with the people tagged as being with them when checking in * **`FOURSQUARE_DAILY_CHECKINS`**: the number of consumers who checked into your business on Foursquare on a given date * **`INSTAGRAM_POSTS`**: the number of times consumers posted Instagram content geotagged at your business * **`GOOGLE_SEARCH_QUERIES`**: the number of times your listings appeared in search results on either Google Search or Google Maps * **`GOOGLE_SEARCH_VIEWS`**: the number of times your listings were viewed on Google Search * **`GOOGLE_MAP_VIEWS`**: the number of times your listings were viewed on Google Maps * **`GOOGLE_CUSTOMER_ACTIONS`**: the number of times consumers called your business, got driving directions to your business, or visited your website via the links in your Google listings * **`GOOGLE_PHONE_CALLS`**: the number of times consumers called your business by clicking your phone number in your Google listings during the past 90 days. You must use the `GOOGLE_PHONE_CALL_HOURS` dimension with this metric. * **`AVERAGE_RATING`**: the cumulative average of the ratings your business has received * **`NEW_REVIEWS`**: the number of new reviews your business has received * **`STOREPAGES_SESSIONS`**:  the number of unique visitors (sessions) to your Store Pages. * **`STOREPAGES_PAGEVIEWS`**:  the number of page views on your Store Pages. * **`STOREPAGES_DRIVINGDIRECTIONS`**:  the number of times someone clicked for directions on your Store Pages. * **`STOREPAGES_PHONECALLS`**:  the number of times someone clicked to make a phone call from your Store Pages. * **`STOREPAGES_CALLTOACTIONCLICKS`**:  the number of times someone clicked a call to action on your Store Pages. * **`STOREPAGES_CLICKSTOWEBSITE`**:  the number of times someone clicked to go to your website from your Store Pages. * **`STOREPAGES_EVENT_eventtype`**:  the number of times the Store Pages custom event occurred. * **`PROFILE_UPDATES`**: Count of updates to your Yext profile. * **`PUBLISHER_SUGGESTIONS`**: Count of all publisher suggestions. * **`SOCIAL_ACTIVITIES`**: Count of all new social posts. * **`DUPLICATES_SUPPRESSED`**: Count of all duplicates suppressed. * **`DUPLICATES_DETECTED`**: Count of all duplicates detected. * **`LISTINGS_LIVE`**: Count of new listings live.
     * @return $this
     */
    public function setMetrics($metrics)
    {
        $this->container['metrics'] = $metrics;

        return $this;
    }

    /**
     * Gets dimension
     * @return string[]
     */
    public function getDimension()
    {
        return $this->container['dimension'];
    }

    /**
     * Sets dimension
     * @param string[] $dimension Determines how the data will be grouped. Specify up to 3 values. <br><br> **NOTES:** <br> You can only use one time-based dimension (e.g., `DAYS`, `WEEKS`) per report. <br> You can only use one location-based dimenion (e.g., `FOLDER_IDS`, `LOCATION_NAMES`) per report. <br><br> * **`ACCOUNT_IDS`** * **`LOCATION_IDS`** * **`FOLDER_IDS`** * **`LOCATION_NAMES`** * **`FOLDER_NAMES`** * **`DAYS`** * **`WEEKS`** * **`MONTHS`**: refers to the Gregorian calendar (January, February, etc.) * **`MONTHS_RETAIL`**: refers to the 4-5-4 merchandising calendar * **`PLATFORM`**: groups data by the platform on which the action measured in **`metrics`** was conducted (e.g., Desktop, Mobile) * **`FOURSQUARE_GENDER`**: groups checkins by users' sexes (`male` or `female`). Can only be used with the `FOURSQUARE_DAILY_CHECKINS` metric. * **`FOURSQUARE_AGE`**: groups checkins by the users' ages (`13-17`, `18-24`, `25-34`, `35-44`, `45-54`, `55+`). Can only be used with the `FOURSQUARE_DAILY_CHECKINS` metric. * **`FOURSQUARE_TIME`**: groups checkins by their times (`morning`: 7 AM - 10:59 AM, `noon`: 11 AM - 1:59 PM, `afternoon`: 2 PM - 5:59 PM, `evening`: 6 PM - 8:59 PM, `night`: 9 PM - 6:59 AM). Can only be used with the `FOURSQUARE_DAILY_CHECKINS` metric. * **`SEARCH_QUERY`**: groups searches according to the search criteria used. Can only be used with the `SEARCHES` metric. * **`GOOGLE_ACTION_TYPE`**: the type of action consumers took through your Google listings (Phone Calls, Get Directions, or Website Clicks). Can only be used with the `GOOGLE_CUSTOMER_ACTIONS` metric. * **`GOOGLE_QUERY_TYPE`**: groups search criteria based on whether they contained your brand name (branded) or not (unbranded). Can only be used with the `GOOGLE_SEARCH_QUERIES` metric. * **`GOOGLE_PHONE_CALL_HOURS`**: can only be used with the `GOOGLE_PHONE_CALLS` metric * **`RATINGS`**: can only be used with the `AVERAGE_RATING` and `NEW_REVIEWS` metrics * **`FREQUENT_WORDS`**: the words that most frequently appear in your reviews. Can only be used with the `AVERAGE_RATING` and `NEW_REVIEWS` metrics. * **`PARTNERS`**: the sites your reviews appear on. Can only be used with the `AVERAGE_RATING` and `NEW_REVIEWS` metrics. * **`STOREPAGES_PAGE_TYPE`**: the page types for your Store Pages. Can only be used with Store Pages metrics. * **`STOREPAGES_PAGE_URL`**: the urls people visited on your Store Pages. Can only be used with Store Pages metrics. * **`STOREPAGES_DIRECTORY`**: the directories of your Store Pages. Can only be used with Store Pages metrics. * **`PUBLISHER_SUGGESTION_TYPE`**: the type of the publisher suggestion (can only be used with the `PUBLISHER_SUGGESTIONS` metric). * **`FIELD_NAME`**: the name of the field being updated in your profile (can only be used with the `PROFILE_UPDATES` metric). * **`LISTINGS_LIVE_TYPE`**: The type of of listings live, either be `Claimed` or `Created` (can only be used with `LISTINGS_LIVE` metric).
     * @return $this
     */
    public function setDimension($dimension)
    {
        $this->container['dimension'] = $dimension;

        return $this;
    }

    /**
     * Gets filters
     * @return \Yext\Client\Model\AnalyticsFilter
     */
    public function getFilters()
    {
        return $this->container['filters'];
    }

    /**
     * Sets filters
     * @param \Yext\Client\Model\AnalyticsFilter $filters
     * @return $this
     */
    public function setFilters($filters)
    {
        $this->container['filters'] = $filters;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     * @param  integer $offset Offset
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     * @param  integer $offset Offset
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     * @param  integer $offset Offset
     * @param  mixed   $value  Value to be set
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     * @param  integer $offset Offset
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(\Yext\Client\ObjectSerializer::sanitizeForSerialization($this), JSON_PRETTY_PRINT);
        }

        return json_encode(\Yext\Client\ObjectSerializer::sanitizeForSerialization($this));
    }
}
